#IMPORT NOTES
# -*- coding: utf-8 -*-
""" NEU_NAW-Testauswertung.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V52xU9y5Jh3iqCTf7yi5uAAu3iFDrQV3
"""

#ONLY FOR GOOGLE COLAB
  # Commented out IPython magic to ensure Python compatibility.
  #from google.colab import drive
  #drive.mount('/gdrive')
  # %cd /gdrive

######### FIRST MANUALY INSTALL THESE IN TERMINAL #########
#pip3 install PyMuPDF
#pip3 install boxdetect
#pip3 install pillow #called as PIL (Python Image Library)
#pip3 install requests #### INSTALL WORKS BUT IMPORT DOES NOT!?! NOT EVEN NEEDED?

#import requests as req #NOT EVEN NEEDED?
import os
import glob, sys, fitz # wird alles für PyMuPDF benötigt
from boxdetect import config
from boxdetect.pipelines import get_checkboxes
import matplotlib.pyplot as plt
from PIL import Image
#from google.colab.patches import cv2_imshow #only needed in google colab
import cv2 #openCV needed to draw rectangle on image
import re #needed for regex in filename

# To get better resolution
zoom_x = 2.0  # horizontal zoom
zoom_y = 2.0  # vertical zoom
mat = fitz.Matrix(zoom_x, zoom_y)  # zoom factor 2 in each dimension

def boxDetectSetup():
  cfg = config.PipelinesConfig()
  # important to adjust these values to match the size of boxes on your image
  cfg.width_range = (25,38) #(18,30)
  cfg.height_range = (25,38) #(18,30)

  # the more scaling factors the more accurate the results but also it takes more time to processing
  # too small scaling factor may cause false positives
  # too big scaling factor will take a lot of processing time
  cfg.scaling_factors = [0.5] # 0.7

  # w/h ratio range for boxes/rectangles filtering
  cfg.wh_ratio_range = (0.8, 1.2) #(0.8, 1.2)

  # group_size_range starting from 2 will skip all the groups
  # with a single box detected inside (like checkboxes)
  cfg.group_size_range = (1, 1)

  # num of iterations when running dilation tranformation (to engance the image)
  cfg.dilation_iterations = 0
def coordValuesOnPages():
  safety_border = 50 #20

  coord_page_1 = [[1006, 1353],
                  [1006, 1403],
                  [1006, 1453],
                  [1006, 1503],
                  [1006, 1552]] #coordinates are CENTERS of checkboxes; example for 3 checkboxes; safety-border (ca. 20px) gets added dynamically when checking occurs
  coord_page_2 = [[]] #page 2 in document is empty!
  coord_page_3 = [[123, 473],
                  [123, 739],
                  [123, 1039],
                  [123, 1315]] #4 checkboxes
  coord_page_4 = [[201, 555],
                  [720, 555],
                  [201, 1017],
                  [729, 1017]] #4 checkboxes
  coord_page_5 = [[132, 1095],
                  [132, 1173],
                  [132, 1251],
                  [132, 1325]] #4 checkboxes
  coord_page_6 = [[198, 1017],
                  [198, 1117],
                  [198, 1210],
                  [198, 1316]] #4 checkboxes
  coord_page_7 = [[139, 459],
                  [139, 681],
                  [139, 898],
                  [139, 1138]] #4 checkboxes
  coord_page_8 = [[190, 452],
                  [190, 689],
                  [190, 924],
                  [190, 1151]] #4 checkboxes
  coord_page_9 = [[136, 1082],
                  [136, 1185],
                  [136, 1288],
                  [136, 1392]] #4 checkboxes
  coord_page_10 = [[186, 450],
                  [186, 680],
                  [186, 922],
                  [186, 1164]] #4 checkboxes
  coord_page_11 = [[131, 1082],
                  [131, 1186],
                  [131, 1289],
                  [131, 1392]] #4 checkboxes
  coord_page_12 = [[186, 454],
                  [186, 691],
                  [186, 925],
                  [186, 1153]] #4 checkboxes
  coord_page_13 = [[342, 597],
                  [342, 780],
                  [342, 963],
                  [342, 1145]] #4 checkboxes
  coord_page_14 = [[187, 1168],
                  [187, 1263],
                  [187, 1359],
                  [187, 1453]] #4 checkboxes
  coord_page_15 = [[155, 712],
                  [155, 874],
                  [155, 1035],
                  [155, 1196]] #4 checkboxes
  coord_page_16 = [[253, 705],
                  [253, 869],
                  [253, 1034],
                  [253, 1204]] #4 checkboxes
  coord_page_17 = [[114, 976],
                  [114, 1070],
                  [114, 1166],
                  [114, 1261]] #4 checkboxes
  coord_page_18 = [[217, 797],
                  [217, 900],
                  [217, 1004],
                  [217, 1108]] #4 checkboxes
  coord_page_19 = [[294, 771],
                  [294, 954],
                  [294, 1136],
                  [294, 1319]] #4 checkboxes
boxDetectSetup() #call functions
coordValuesOnPages() #call functions

#only import correctly named sets of 19 pages
folder_path = "/gdrive/MyDrive/RescueOMR_NAW-Test/gdrive/MyDrive/TESTKOPIE_L105_NAW-1_komplett/" ######## CHANGE PATH
all_files = glob.glob(folder_path + "*.pdf") #finds all PDFs in path from folder




for filename in all_files:

#  filename_shortened = filename.replace("_komplett_split-run-[0-9]+.pdf","") # anzupassen für Production
  filename_shortened = filename.replace(".pdf","") # anzupassen für Production
  filename_shortened = filename_shortened.replace("/gdrive/MyDrive/RescueOMR_NAW-Test/gdrive/MyDrive/TESTKOPIE_","") # anzupassen für Production
  filename_shorter = filename_shortened.replace("L105_NAW-1_komplett/","")
### CREATE HERE DIRECTORY FOR SCHUELER SUBFOLDER OF STUDENT
  dir_name = "{}{}".format(folder_path, filename_shortened)
  #create directory command
  os.makedirs(dir_name, exist_ok=True) #ok=False ## only create if not existing? TRY EXCEPT. unten bei save image Pfad anpassen!
  doc = fitz.open(filename)  # open document
### CREATE EXCEPTION WITH CONTINUATION WHEN NOT 19 PAGES IN DOCUMENT
  if doc.page_count == 19:
    print("OK: Korrekte Seitenanzahl")
  else:
    print("ERROR: Falschen Seitenanzahl. {} statt 19 Seiten.".format(doc.page_count))
  for page in doc:  # iterate through the pages
    pix = page.get_pixmap(matrix=mat)  # render page to an image
    pix.save("{}/{}_page-{}.png".format(dir_name, filename_shorter, page.number+1))  # store image as a PNG


"""Boxdetect"""
# load image ## MAKE DYNAMIC FOR PRODUCTION - LOOP THROUGH DIRECTORY - create list!
img_path = dir_name
for img in os.listdir(img_path):
  #print(img) #for debugging
  checkboxes = get_checkboxes(
    img, cfg=cfg, px_threshold=0.3, plot=False, verbose=True) #px_threshold=0.6
  print("Output object type: ", type(checkboxes))
  for checkbox in checkboxes:
      print("Checkbox bounding rectangle (x,y,width,height): ", checkbox[0])
      print("Result of `contains_pixels` for the checkbox: ", checkbox[1])
      print("Display the cropout of checkbox:")
      plt.figure(figsize=(1,1))
      plt.imshow(checkbox[2])
      plt.show()

  img_annot = cv2.imread(img)

  # IMPLEMENT HERE: ("Result of `contains_pixels` for the checkbox: ", checkbox[1]) (TRUE-FALSE) TO CSV-List

  box_shift = 50 #shift-value for checkbox drawing for screening

  #detect page from filename
  page_detected = re.findall("page-[0-9]+",img) #isolate e.g. "page-1"
  page_detected = re.findall("[0-9]+", page_detected[0]) #isolate number from e.g. "page-1" = "1"

  for checkbox in checkboxes:
    cb_values = checkbox[0] #export list from checkbox-nd.array
    cb_xmin = cb_values[0] #x=width-axis
    cb_xmax = cb_values[0]+cb_values[2]
    cb_ymin = cb_values[1] #y=height-axis
    cb_ymax = cb_values[1]+cb_values[3]
    #print(cb_xmin, " - ", cb_xmax, " - ",cb_ymin, " - ",cb_ymax, " - ",) # only for debugging
    
    #MAKE CHECK IF CHECKBOX TWICE ON SAME COORDINATE AND IF A COORDINATE WITHOUT CHECKBOX EXISTS # WRITE ERROR CODES TO IMG AS RED TEXT!
    coord_page = "coord_page_{}".format(page_detected[0]) #
    print(coord_page)

    for i in eval(coord_page): # eval() is used to select variable based on string
      #TRY: CREATE ERROR HANDLER?
      print("Position {}: ".format(i))#, end="")
      if cb_xmin > i[0]-safety_border and cb_xmax < i[0]+safety_border and cb_ymin > i[1]-safety_border and cb_ymax < i[1]+safety_border:
        print("checkbox found, with value={}".format(checkbox[1])) #CREATE HERE INPUT TO CSV WITH TRUE/1 AND COMMA ++ DRAW Checkbox an value to COPY of image (subdirectory)
        if checkbox[1] == True:
          cv2.rectangle(img_annot, (cb_xmin-box_shift, cb_ymin), (cb_xmax-box_shift, cb_ymax), (255, 0, 0), -1)
          #cv2.rectangle(img_annot, (50, 50), (100, 100), (0, 255, 0), -1)
        elif checkbox[1] == False:
          cv2.rectangle(img_annot, (cb_xmin-box_shift, cb_ymin), (cb_xmax-box_shift, cb_ymax), (255, 0, 0), 2)
          #cv2.rectangle(img_annot, (50, 50), (100, 100), (0, 255, 0))
      else:
        print("not found") #CREATE HERE INPUT TO CSV WITH FALSE/0 AND COMMA
    print("--------") # NEW ROW IN CSV?

cv2_imshow(img_annot)
    # SAVE IMAGE WITH NEW NAME